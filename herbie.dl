
//.type gmp_rat <: symbol
#include "gmp.dl"
.type Expr = Lit {n : float} | Add {x : Expr, y : Expr} | X {} // | Mul {} // div? | X {}

.decl top(x : Expr)

.decl term(x : Expr)
term(x) :- top(x).
term(x),term(y) :- term($Add(x,y)).

term(x) :- eq(x,_).
eq(x,x) :- term(x).

.decl eq(x : Expr, y : Expr) eqrel
eq(t, $Add(x,$Add(y,z))) :- term(t), t = $Add($Add(x,y),z).
eq(t, $Add($Add(x,y),z)) :- term(t), t = $Add(x,$Add(y,z)).
eq(t, $Add(y,x)) :- term(t), t = $Add(x,y).

/*
eval(t : Expr, n : float).
eval(t, n) :- term(t), t = $Lit(n).
eval(t, nx + ny) :- term(t), t = $Add(x,y), eval(x,nx), eval(y,ny).
*/

#define NSAMP 10
.decl sample(s : unsigned, x : float)
sample(s, to_float(s)/NSAMP) :- s = range(0,NSAMP).

.decl eval(s : unsigned, t : Expr, n : float)
eval(s, t, n) :- term(t), t = $Lit(n), sample(s, _).
eval(s, t, x) :- term(t), t = $X(), sample(s, x).
eval(s, t, nx + ny) :- term(t), t = $Add(x,y), eval(s,x,nx), eval(s,y,ny).


.decl exact(s : unsigned, t : Expr, n : mpq)
exact(s,t,Q(n)) :- term(t), t = $Lit(n), sample(s,_).
exact(s,t,Q(x)) :- term(t), t = $X(), sample(s,x).
exact(s,t,@mpqs_add(nx,ny)) :- term(t), t = $Add(x,y), exact(s,x,nx), exact(s,y,ny).

.decl err(s : unsigned, t : Expr, e : float) // should error be mpq? probably but it makes minimum kind of annoying
err(s, t, @float_of_mpqs(e)) :- eval(s,t,x1), exact(s,t,x2), e = @mpqs_abs(@mpqs_sub(Q(x1), x2)).

.decl best(s : unsigned, t : Expr, e : float)
best(s, t1, be) :- term(t), s = range(0,10), be = min e: {err(s, t1, e), eq(t,t1)}, eq(t,t1), err(s,t1,be).



top($Add($Add($Lit(1),$X()),$Lit(10000))).
//.output eval(IO=stdout)
//.output sample(IO=stdout)
//.output exact(IO=stdout)
.output best(IO=stdout)